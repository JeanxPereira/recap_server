
// Include
#include "level.h"

#include "utils/functions.h"
#include "utils/log.h"

// TODO: for all xml formats, use attributes aswell. (current data is autogenerated)

// Game
namespace Game {
	const auto read_list = [](pugi::xml_node node, std::string_view nodeName, auto& list) {
		for (const auto& child : node.child(nodeName.data())) {
			if (child.name() != "entry") {
				continue;
			}

			decltype(auto) data = list.emplace_back();
			data.Read(child);
		}
	};

	// Marker
	void Marker::Read(pugi::xml_node node) {
		const auto read_vec3 = [&](std::string_view nodeName) {
			glm::vec3 data;
			data.x = utils::xml_get_text_node<float>(node, "x");
			data.y = utils::xml_get_text_node<float>(node, "y");
			data.z = utils::xml_get_text_node<float>(node, "z");
			return data;
		};

		mName = utils::xml_get_text_node(node, "markerName");
		mId = utils::xml_get_text_node<uint32_t>(node, "markerId");
		mNounName = utils::xml_get_text_node(node, "nounDef");

		mPosition = read_vec3("pos");
		mRotation = read_vec3("rotDegrees");
		mScale = utils::xml_get_text_node<float>(node, "scale");

		mVisible = utils::xml_get_text_node<bool>(node, "visible");
		mHasCollision = utils::xml_get_text_node<bool>(node, "createWithCollision");

		mOverrideAssetId = utils::xml_get_text_node<uint64_t>(node, "assetOverrideId");
		mTargetId = utils::xml_get_text_node<uint32_t>(node, "targetMarkerId");

		/*
			<componentData>
				<spawnPointDef>
					<sectionType>3</sectionType>
					<activatesSpike>true</activatesSpike>
				</spawnPointDef>
			</componentData>
		*/
	}

	// Markerset
	void Markerset::Read(pugi::xml_node node) {
		read_list(node, "markers", mMarkers);
	}

	// DirectorClass
	void DirectorClass::Read(pugi::xml_node node) {
		mNounName = utils::xml_get_text_node(node, "mpNoun");

		mMinLevel = utils::xml_get_text_node<int32_t>(node, "minDifficulty");
		mMaxLevel = utils::xml_get_text_node<int32_t>(node, "maxDifficulty");

		mHordeLegal = utils::xml_get_text_node<bool>(node, "hordeLegal");
	}

	// LevelConfig
	void LevelConfig::Read(pugi::xml_node node) {
		read_list(node, "minion", mMinions);
		read_list(node, "special", mSpecial);
		read_list(node, "boss", mBoss);
		read_list(node, "agent", mAgent);
		read_list(node, "captain", mCaptain);
	}

	// Level
	Level::Level() {

	}

	Level::~Level() {

	}

	bool Level::Load(const std::string& path) {
		pugi::xml_document document;
		if (auto parse_result = document.load_file(path.c_str())) {
			auto levelNode = document.child("level");
			if (!levelNode) {
				return false;
			}

			if (auto markersetsNode = levelNode.child("markersets")) {
				for (const auto& child : markersetsNode) {
					if (child.name() != "entry") {
						continue;
					}
					mMarkersets.push_back(utils::xml_get_text_node(child, "markersetAsset"));
				}
			}

			mConfig.Read(levelNode.child("levelConfig"));
			mFirstTimeConfig.Read(levelNode.child("firstTimeConfig"));

			std::string planetConfigName = utils::xml_get_text_node(levelNode, "planetConfig");
			if (!planetConfigName.empty()) {
				// mPlanetConfig.Read(open_the_file);
			}
		} else {
			std::cout << "Level: Could not load '" << path << "'." << std::endl;
			return false;
		}
		return true;
	}

	void Level::Reload() {
		// mGame.ReloadLevel();
	}
}
